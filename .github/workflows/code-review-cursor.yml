name: AI Code Review (Cursor CLI)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  cursor-code-review:
    name: Cursor AI Code Review
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    
    # Concurrencia: evitar m√∫ltiples ejecuciones simult√°neas del mismo PR
    concurrency:
      group: code-review-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Install Cursor CLI
        run: |
          curl https://cursor.com/install -fsS | bash
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH

      - name: Configure git identity
        run: |
          git config user.name "Cursor AI Reviewer"
          git config user.email "cursor-reviewer@noreply.github.com"

      - name: Select optimal AI model based on PR size
        id: select-model
        env:
          MODEL_CONFIG: ${{ vars.MODEL || 'auto' }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Si MODEL est√° configurado manualmente y no es 'auto', usarlo directamente
          if [ "$MODEL_CONFIG" != "auto" ]; then
            echo "MODEL=$MODEL_CONFIG" >> $GITHUB_OUTPUT
            echo "MODEL_REASON=Manually configured" >> $GITHUB_OUTPUT
            echo "Using manually configured model: $MODEL_CONFIG"
            exit 0
          fi
          
          # Obtener m√©tricas del PR
          PR_DATA=$(gh pr view ${{ github.event.pull_request.number }} --json additions,deletions,files --jq '{additions, deletions, files: (.files | length)}')
          ADDITIONS=$(echo $PR_DATA | jq -r '.additions')
          DELETIONS=$(echo $PR_DATA | jq -r '.deletions')
          FILES=$(echo $PR_DATA | jq -r '.files')
          TOTAL_LINES=$((ADDITIONS + DELETIONS))
          
          echo "PR Analysis:"
          echo "  Additions: $ADDITIONS lines"
          echo "  Deletions: $DELETIONS lines"
          echo "  Total changes: $TOTAL_LINES lines"
          echo "  Files changed: $FILES"
          
          # Selecci√≥n autom√°tica basada en tama√±o y complejidad
          # PRIORIDAD: Claude siempre primero > GPT como fallback > Gemini como √∫ltimo recurso
          # PR peque√±o: cambios menores, pocos archivos
          if [ "$TOTAL_LINES" -lt 500 ] && [ "$FILES" -lt 10 ]; then
            SELECTED_MODEL="claude-3-5-sonnet"
            REASON="Small PR: Claude (priority), fallback: GPT-4o, then Gemini"
          
          # PR mediano-peque√±o: cambios moderados
          elif [ "$TOTAL_LINES" -lt 1500 ] && [ "$FILES" -lt 25 ]; then
            SELECTED_MODEL="claude-3-5-sonnet"
            REASON="Medium PR: Claude (priority), fallback: GPT-4, then Gemini"
          
          # PR mediano-grande: cambios significativos
          elif [ "$TOTAL_LINES" -lt 3000 ] && [ "$FILES" -lt 40 ]; then
            SELECTED_MODEL="claude-3-5-sonnet-200k"
            REASON="Large PR: Claude (priority), fallback: GPT-4o-128k, then Gemini"
          
          # PR grande: muchos cambios y archivos
          elif [ "$TOTAL_LINES" -lt 10000 ] && [ "$FILES" -lt 60 ]; then
            SELECTED_MODEL="claude-3-5-sonnet-200k"
            REASON="Very large PR: Claude (priority), fallback: GPT-4o-128k, then Gemini"
          
          # PR masivo: cambios extremos - Claude primero, luego GPT-4o-128k, finalmente Gemini
          else
            SELECTED_MODEL="claude-3-5-sonnet-200k"
            REASON="Massive PR: Claude (priority), fallback: GPT-4o-128k, then Gemini-1.5-flash-500k"
          fi
          
          # Nota: Si Claude no est√° disponible, Cursor CLI autom√°ticamente intentar√° fallback a GPT,
          # y si GPT tampoco est√° disponible, intentar√° Gemini seg√∫n configuraci√≥n de Cursor
          
          echo "Selected model: $SELECTED_MODEL ($REASON)"
          echo "MODEL=$SELECTED_MODEL" >> $GITHUB_OUTPUT
          echo "MODEL_REASON=$REASON" >> $GITHUB_OUTPUT

      - name: Perform automated code review with Cursor
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          # MODEL: Configura el modelo de IA a usar
          #   - 'auto' (default): Selecci√≥n autom√°tica basada en tama√±o del PR
          #     Prioridad de modelos: Claude > GPT > Gemini
          #   Modelos Claude (prioritarios):
          #   - 'claude-3-5-sonnet': Excelente para c√≥digo complejo (default para PRs peque√±os/medianos)
          #   - 'claude-3-5-sonnet-200k': Claude 3.5 Sonnet con contexto muy largo (default para PRs grandes)
          #   - 'claude-3-haiku-200k': R√°pida para contextos largos
          #   - 'claude-3-sonnet-200k': Sonnet con contexto largo
          #   Modelos GPT (fallback si Claude no disponible):
          #   - 'gpt-4': Precisa y detallada, mejor para an√°lisis complejos
          #   - 'gpt-4o': M√°s r√°pida y eficiente, buena calidad
          #   - 'gpt-4o-128k': Para PRs muy grandes (hasta 128k tokens)
          #   Modelos Gemini (fallback final):
          #   - 'gemini-1.5-flash-500k': Para PRs extremadamente grandes (hasta 500k tokens)
          #   Otros:
          #   - 'cursor-small': R√°pida y ligera para reviews simples
          MODEL: ${{ steps.select-model.outputs.MODEL }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BLOCKING_REVIEW: ${{ vars.BLOCKING_REVIEW || 'false' }}
          REVIEW_MAX_COMMENTS: ${{ vars.REVIEW_MAX_COMMENTS || '20' }}
          REVIEW_DETAIL_LEVEL: ${{ vars.REVIEW_DETAIL_LEVEL || 'detailed' }}
        run: |
          cursor-agent --force --model "$MODEL" --output-format=text --print 'You are operating in a GitHub Actions runner performing automated code review for embedded systems firmware. The gh CLI is available and authenticated via GH_TOKEN. You may comment on pull requests.

          Context:
          - Repo: ${{ github.repository }}
          - PR Number: ${{ github.event.pull_request.number }}
          - PR Head SHA: ${{ github.event.pull_request.head.sha }}
          - PR Base SHA: ${{ github.event.pull_request.base.sha }}
          - Blocking Review: ${{ env.BLOCKING_REVIEW }}
          - Project Type: Embedded Systems Firmware (C/C++)
          - Review Detail Level: ${{ env.REVIEW_DETAIL_LEVEL }}
          - Max Comments: ${{ env.REVIEW_MAX_COMMENTS }}
          - Selected Model: ${{ env.MODEL }} (auto-selected based on PR size)
          
          Objectives:
          1) Review the current PR diff and flag issues specific to embedded firmware development (all severity levels if detail level is detailed).
          2) Leave concise inline comments (1-2 sentences) on changed lines only.
          3) Provide a comprehensive summary with statistics at the end.
          4) Check if existing review comments have been addressed.
          5) Prioritize fixes by severity and impact.

          Procedure:
          - Get existing comments: gh pr view --json comments
          - Get diff: gh pr diff
          - Get changed files with patches: gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files --paginate --jq '".[] | {filename,patch}"'
          - Compute exact inline anchors for each issue (file path + diff position).
          - Comments MUST be placed inline on the changed line in the diff, not as top-level comments.
          - Focus on files with extensions: .c, .cpp, .h, .hpp, .cc, .cxx

          Focus Areas (Embedded Systems - All Severity Levels):
          
          MEMORY MANAGEMENT:
          - Stack/heap overflow risks (analyze stack sizes, dynamic allocations)
          - Memory leaks (malloc/free, new/delete mismatches)
          - Buffer overflows/underflows
          - Static vs dynamic allocation best practices
          - Memory fragmentation issues
          - Stack usage estimation and warnings
          - Double free or use-after-free vulnerabilities
          - Uninitialized memory access
          
          RTOS COMMON PATTERNS:
          - FreeRTOS: tasks, queues, semaphores, mutexes, timers
          - Zephyr: threads, work queues, kernel objects, device drivers
          - ThreadX: threads, queues, timers, event flags
          - Bare metal: interrupts, state machines, event loops
          - Task priorities and scheduling
          - Task stack size adequacy
          
          CONCURRENCY & THREADING:
          - Race conditions in multi-threading contexts
          - Deadlocks and livelocks
          - Critical sections and protection of shared data
          - Interrupt safety (ISR vs task context, reentrancy)
          - Preemption issues
          - Mutex/semaphore usage patterns
          - Lock ordering to prevent deadlocks
          
          RESOURCE MANAGEMENT:
          - Resource leaks (handles, timers, peripherals)
          - Lifecycle management (init/deinit pairs)
          - Peripheral configuration conflicts
          - GPIO/hardware state management
          - DMA channel management
          - Interrupt handler registration/cleanup
          
          ERROR HANDLING & ROBUSTNESS:
          - Error handling in critical operations
          - Retry logic and timeouts
          - Watchdog management and feeding
          - Failure recovery mechanisms
          - Null pointer checks before dereferencing
          - Assertions vs error returns (appropriate usage)
          - Edge case handling
          - Input validation
          
          PERFORMANCE:
          - Blocking calls in ISRs (critical anti-pattern)
          - Excessive polling (use interrupts instead)
          - Inefficient algorithms for resource-constrained environments
          - Power consumption patterns and optimization opportunities
          - CPU usage optimization
          - Loop optimization (unnecessary iterations)
          - Function call overhead in hot paths
          
          SECURITY:
          - Buffer overflows
          - Integer overflows and underflows
          - Unsafe string functions (strcpy, sprintf, etc.)
          - Cryptographic implementation flaws (if applicable)
          - Secure boot / OTA security (if applicable)
          - Secret/hardcoded credentials
          - Side-channel vulnerabilities
          
          EMBEDDED CODE PATTERNS:
          - Volatile usage (registers, shared memory)
          - Register access patterns (read-modify-write correctness)
          - Bit manipulation correctness
          - Interrupt priorities configuration
          - DMA configuration and synchronization
          - Hardware abstraction layers (proper abstraction)
          - Endianness considerations
          - Atomic operations (when needed)
          
          CODE QUALITY & STYLE:
          - Compliance with clang-format style (check if code follows project .clang-format)
          - Naming conventions consistency
          - Function complexity (avoid overly long functions)
          - Cyclomatic complexity warnings
          - Magic numbers (use constants/config instead)
          - Documentation (comments in critical functions)
          - Code organization and structure
          - Duplicate code detection
          
          READABILITY & BEST PRACTICES:
          - Variable naming clarity
          - Function and module organization
          - Code comments quality and necessity
          - Consistent coding style
          - Type safety improvements
          - Const correctness
          - Macro usage appropriateness

          Commenting rules:
          - Max ${{ env.REVIEW_MAX_COMMENTS }} inline comments total; prioritize critical issues first, then include all severity levels
          - One issue per comment; place on the exact changed line
          - All issue comments MUST be inline (anchored to file and line/position in PR diff)
          - Natural, specific, and actionable tone
          - Use emojis to categorize: üö® Critical üîí Security ‚ö° Performance ‚ö†Ô∏è Logic ‚úÖ Resolved ‚ú® Improvement üíæ Memory üîß Style üìù Documentation üìñ Readability üí° Best Practice
          - Include severity level in comment when not obvious from emoji

          Submission:
          - If NO issues found, submit one brief summary comment: "‚úÖ Code review: No issues found. The changes look good!"
          - If issues ARE found, submit ONE review containing inline comments plus a comprehensive summary body.
          - Summary body MUST include:
            * Statistics by category (Critical: X, Security: Y, Performance: Z, etc.)
            * List of files with most issues
            * Priority recommendations (what to fix first)
            * General recommendations for improvement
          - Use GitHub Reviews API to ensure comments are inline:
            - Build JSON array: [{ "path": "<file>", "position": <diff_position>, "body": "..." }]
            - Submit via: gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews -f event=COMMENT -f body="$SUMMARY" -f comments='[$COMMENTS_JSON]'
          - Track comment categories in environment for blocking behavior

          Blocking behavior:
          - Count critical (üö®) and security (üîí) issues found
          - If BLOCKING_REVIEW is true and any üö® or üîí issues were posted: echo "CRITICAL_ISSUES_FOUND=true" >> $GITHUB_ENV
          - Otherwise: echo "CRITICAL_ISSUES_FOUND=false" >> $GITHUB_ENV
          - Always set CRITICAL_ISSUES_FOUND at the end
          '

      - name: Check blocking review results
        if: env.BLOCKING_REVIEW == 'true'
        run: |
          if [ "${CRITICAL_ISSUES_FOUND:-false}" = "true" ]; then
            echo "‚ùå Critical issues found and blocking review is enabled. Failing the workflow."
            exit 1
          else
            echo "‚úÖ No blocking issues found."
          fi

      - name: Summary
        env:
          MODEL_USED: ${{ steps.select-model.outputs.MODEL }}
          MODEL_REASON: ${{ steps.select-model.outputs.MODEL_REASON }}
        run: |
          echo "‚úÖ Code review con Cursor AI completado"
          echo "Modelo utilizado: $MODEL_USED ($MODEL_REASON)"
          echo "Revisa los comentarios en el Pull Request"
