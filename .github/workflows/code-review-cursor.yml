name: AI Code Review (Cursor CLI)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  cursor-code-review:
    name: Cursor AI Code Review
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    
    # Concurrencia: evitar m√∫ltiples ejecuciones simult√°neas del mismo PR
    concurrency:
      group: code-review-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
          persist-credentials: false

      - name: Validate required secrets
        run: |
          if [ -z "${{ secrets.CURSOR_API_KEY }}" ]; then
            echo "‚ùå Error: CURSOR_API_KEY secret is not configured"
            echo "Please configure it in: Settings > Secrets and variables > Actions"
            exit 1
          fi
          echo "‚úÖ CURSOR_API_KEY is configured"

      - name: Install Cursor CLI
        run: |
          # Download and verify Cursor CLI installation script
          INSTALL_URL="https://cursor.com/install"
          echo "Downloading Cursor CLI installer..."
          curl -fsSL "$INSTALL_URL" -o /tmp/cursor-install.sh
          
          # Basic validation: check if script contains expected content
          if ! grep -q "cursor" /tmp/cursor-install.sh 2>/dev/null; then
            echo "‚ùå Error: Failed to download valid Cursor CLI installer"
            exit 1
          fi
          
          # Execute installer with error handling
          bash /tmp/cursor-install.sh || {
            echo "‚ùå Error: Failed to install Cursor CLI"
            exit 1
          }
          
          # Verify installation
          if [ ! -d "$HOME/.cursor/bin" ]; then
            echo "‚ùå Error: Cursor CLI was not installed correctly"
            exit 1
          fi
          
          echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          echo "‚úÖ Cursor CLI installed successfully"

      - name: Configure git identity
        run: |
          git config user.name "Cursor AI Reviewer"
          git config user.email "cursor-reviewer@noreply.github.com"

      - name: Select optimal AI model based on PR size
        id: select-model
        env:
          MODEL_CONFIG: ${{ vars.MODEL || 'auto' }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # Si MODEL est√° configurado manualmente y no es 'auto', usarlo directamente
          if [ "$MODEL_CONFIG" != "auto" ]; then
            echo "MODEL=$MODEL_CONFIG" >> $GITHUB_OUTPUT
            echo "MODEL_REASON=Manually configured" >> $GITHUB_OUTPUT
            echo "Using manually configured model: $MODEL_CONFIG"
            exit 0
          fi
          
          # Get PR metrics with error handling
          set +e
          PR_DATA=$(gh pr view ${{ github.event.pull_request.number }} --json additions,deletions,files --jq '{additions, deletions, files: (.files | length)}' 2>&1)
          PR_VIEW_EXIT_CODE=$?
          set -e
          
          if [ $PR_VIEW_EXIT_CODE -ne 0 ]; then
            echo "‚ùå Error: Failed to fetch PR data"
            echo "$PR_DATA"
            exit 1
          fi
          
          ADDITIONS=$(echo "$PR_DATA" | jq -r '.additions // 0')
          DELETIONS=$(echo "$PR_DATA" | jq -r '.deletions // 0')
          FILES=$(echo "$PR_DATA" | jq -r '.files // 0')
          TOTAL_LINES=$((ADDITIONS + DELETIONS))
          
          # Validate numeric values
          if ! [[ "$ADDITIONS" =~ ^[0-9]+$ ]] || ! [[ "$DELETIONS" =~ ^[0-9]+$ ]] || ! [[ "$FILES" =~ ^[0-9]+$ ]]; then
            echo "‚ùå Error: Invalid PR metrics received"
            echo "PR_DATA: $PR_DATA"
            exit 1
          fi
          
          echo "PR Analysis:"
          echo "  Additions: $ADDITIONS lines"
          echo "  Deletions: $DELETIONS lines"
          echo "  Total changes: $TOTAL_LINES lines"
          echo "  Files changed: $FILES"
          
          # Selecci√≥n autom√°tica basada en tama√±o y complejidad
          # PRIORIDAD: Claude (Sonnet/Opus) siempre primero > GPT como fallback > Gemini como √∫ltimo recurso
          # Modelos disponibles en Cursor: sonnet-4.5, opus-4.5, gpt-5, gemini-3-pro
          # PR peque√±o: cambios menores, pocos archivos
          if [ "$TOTAL_LINES" -lt 500 ] && [ "$FILES" -lt 10 ]; then
            SELECTED_MODEL="sonnet-4.5"
            REASON="Small PR: Claude Sonnet (priority), fallback: GPT-5, then Gemini-3-pro"
          
          # PR mediano-peque√±o: cambios moderados
          elif [ "$TOTAL_LINES" -lt 1500 ] && [ "$FILES" -lt 25 ]; then
            SELECTED_MODEL="sonnet-4.5"
            REASON="Medium PR: Claude Sonnet (priority), fallback: GPT-5, then Gemini-3-pro"
          
          # PR mediano-grande: cambios significativos
          elif [ "$TOTAL_LINES" -lt 3000 ] && [ "$FILES" -lt 40 ]; then
            SELECTED_MODEL="sonnet-4.5"
            REASON="Large PR: Claude Sonnet (priority), fallback: GPT-5, then Gemini-3-pro"
          
          # PR grande: muchos cambios y archivos
          elif [ "$TOTAL_LINES" -lt 10000 ] && [ "$FILES" -lt 60 ]; then
            SELECTED_MODEL="opus-4.5"
            REASON="Very large PR: Claude Opus (priority), fallback: GPT-5-high, then Gemini-3-pro"
          
          # PR masivo: cambios extremos - Opus primero, luego GPT-5-high, finalmente Gemini
          else
            SELECTED_MODEL="opus-4.5"
            REASON="Massive PR: Claude Opus (priority), fallback: GPT-5-high, then Gemini-3-pro"
          fi
          
          echo "Selected model: $SELECTED_MODEL ($REASON)"
          echo "MODEL=$SELECTED_MODEL" >> $GITHUB_OUTPUT
          echo "MODEL_REASON=$REASON" >> $GITHUB_OUTPUT

      - name: Validate selected model
        id: validate-model
        env:
          MODEL: ${{ steps.select-model.outputs.MODEL }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
        run: |
          echo "Validating model availability: $MODEL"
          # Note: Actual model validation would require calling Cursor API
          # For now, we log the model and continue
          echo "Model to use: $MODEL"
          echo "MODEL_VALIDATED=true" >> $GITHUB_OUTPUT

      - name: Perform automated code review with Cursor
        timeout-minutes: 30
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          # MODEL: AI model to use
          #   - 'auto' (default): Automatic selection based on PR size
          #     Model priority: Claude (Sonnet/Opus) > GPT > Gemini
          #   Claude models (priority):
          #   - 'sonnet-4.5': Claude Sonnet 4.5 (default for small/medium/large PRs)
          #   - 'sonnet-4.5-thinking': Claude Sonnet with extended reasoning
          #   - 'opus-4.5': Claude Opus 4.5 (best quality, for very large/complex PRs)
          #   - 'opus-4.5-thinking': Claude Opus with extended reasoning
          #   GPT models (fallback if Claude unavailable):
          #   - 'gpt-5': GPT-5 standard
          #   - 'gpt-5.1': GPT-5.1 improved
          #   - 'gpt-5-high': GPT-5 high quality
          #   - 'gpt-5-codex': GPT-5 optimized for code
          #   - 'gpt-5.1-codex': GPT-5.1 optimized for code
          #   - 'opus-4.1': Opus 4.1 (alternative)
          #   Gemini models (final fallback):
          #   - 'gemini-3-pro': Gemini 3 Pro
          #   Other:
          #   - 'composer-1': Composer model
          #   - 'grok': Grok model
          #   - 'auto': Auto-selection by Cursor
          MODEL: ${{ steps.select-model.outputs.MODEL }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BLOCKING_REVIEW: ${{ vars.BLOCKING_REVIEW || 'false' }}
          REVIEW_MAX_COMMENTS: ${{ vars.REVIEW_MAX_COMMENTS || '20' }}
          REVIEW_DETAIL_LEVEL: ${{ vars.REVIEW_DETAIL_LEVEL || 'detailed' }}
        run: |
          set -e
          echo "Starting code review with model: $MODEL"
          
          # Execute cursor-agent with error handling and timeout protection
          cursor-agent --force --model "$MODEL" --output-format=text --print 'You are operating in a GitHub Actions runner performing automated code review for embedded systems firmware. The gh CLI is available and authenticated via GH_TOKEN. You may comment on pull requests.

          Context:
          - Repo: ${{ github.repository }}
          - PR Number: ${{ github.event.pull_request.number }}
          - PR Head SHA: ${{ github.event.pull_request.head.sha }}
          - PR Base SHA: ${{ github.event.pull_request.base.sha }}
          - Blocking Review: ${{ env.BLOCKING_REVIEW }}
          - Project Type: Embedded Systems Firmware (C/C++)
          - Review Detail Level: ${{ env.REVIEW_DETAIL_LEVEL }}
          - Max Comments: ${{ env.REVIEW_MAX_COMMENTS }}
          - Selected Model: ${{ env.MODEL }} (auto-selected based on PR size)
          
          Objectives:
          1) Review the current PR diff and flag issues specific to embedded firmware development (all severity levels if detail level is detailed).
          2) Leave concise inline comments (1-2 sentences) on changed lines only.
          3) Provide a comprehensive summary with statistics at the end.
          4) Check if existing review comments have been addressed.
          5) Prioritize fixes by severity and impact.

          Procedure:
          - Get existing comments: gh pr view --json comments
          - Get diff: gh pr diff
          - Get changed files with patches: gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files --paginate --jq '".[] | {filename,patch}"'
          - Compute exact inline anchors for each issue (file path + diff position).
          - Comments MUST be placed inline on the changed line in the diff, not as top-level comments.
          - Focus on files with extensions: .c, .cpp, .h, .hpp, .cc, .cxx

          Focus Areas (Embedded Systems - All Severity Levels):
          
          MEMORY MANAGEMENT:
          - Stack/heap overflow risks (analyze stack sizes, dynamic allocations)
          - Memory leaks (malloc/free, new/delete mismatches)
          - Buffer overflows/underflows
          - Static vs dynamic allocation best practices
          - Memory fragmentation issues
          - Stack usage estimation and warnings
          - Double free or use-after-free vulnerabilities
          - Uninitialized memory access
          
          RTOS COMMON PATTERNS:
          - FreeRTOS: tasks, queues, semaphores, mutexes, timers
          - Zephyr: threads, work queues, kernel objects, device drivers
          - ThreadX: threads, queues, timers, event flags
          - Bare metal: interrupts, state machines, event loops
          - Task priorities and scheduling
          - Task stack size adequacy
          
          CONCURRENCY & THREADING:
          - Race conditions in multi-threading contexts
          - Deadlocks and livelocks
          - Critical sections and protection of shared data
          - Interrupt safety (ISR vs task context, reentrancy)
          - Preemption issues
          - Mutex/semaphore usage patterns
          - Lock ordering to prevent deadlocks
          
          RESOURCE MANAGEMENT:
          - Resource leaks (handles, timers, peripherals)
          - Lifecycle management (init/deinit pairs)
          - Peripheral configuration conflicts
          - GPIO/hardware state management
          - DMA channel management
          - Interrupt handler registration/cleanup
          
          ERROR HANDLING & ROBUSTNESS:
          - Error handling in critical operations
          - Retry logic and timeouts
          - Watchdog management and feeding
          - Failure recovery mechanisms
          - Null pointer checks before dereferencing
          - Assertions vs error returns (appropriate usage)
          - Edge case handling
          - Input validation
          
          PERFORMANCE:
          - Blocking calls in ISRs (critical anti-pattern)
          - Excessive polling (use interrupts instead)
          - Inefficient algorithms for resource-constrained environments
          - Power consumption patterns and optimization opportunities
          - CPU usage optimization
          - Loop optimization (unnecessary iterations)
          - Function call overhead in hot paths
          
          SECURITY:
          - Buffer overflows
          - Integer overflows and underflows
          - Unsafe string functions (strcpy, sprintf, etc.)
          - Cryptographic implementation flaws (if applicable)
          - Secure boot / OTA security (if applicable)
          - Secret/hardcoded credentials
          - Side-channel vulnerabilities
          
          EMBEDDED CODE PATTERNS:
          - Volatile usage (registers, shared memory)
          - Register access patterns (read-modify-write correctness)
          - Bit manipulation correctness
          - Interrupt priorities configuration
          - DMA configuration and synchronization
          - Hardware abstraction layers (proper abstraction)
          - Endianness considerations
          - Atomic operations (when needed)
          
          CODE QUALITY & STYLE:
          - Compliance with clang-format style (check if code follows project .clang-format)
          - Naming conventions consistency
          - Function complexity (avoid overly long functions)
          - Cyclomatic complexity warnings
          - Magic numbers (use constants/config instead)
          - Documentation (comments in critical functions)
          - Code organization and structure
          - Duplicate code detection
          
          READABILITY & BEST PRACTICES:
          - Variable naming clarity
          - Function and module organization
          - Code comments quality and necessity
          - Consistent coding style
          - Type safety improvements
          - Const correctness
          - Macro usage appropriateness

          Commenting rules:
          - Max ${{ env.REVIEW_MAX_COMMENTS }} inline comments total; prioritize critical issues first, then include all severity levels
          - One issue per comment; place on the exact changed line
          - All issue comments MUST be inline (anchored to file and line/position in PR diff)
          - Natural, specific, and actionable tone
          - Use emojis to categorize: üö® Critical üîí Security ‚ö° Performance ‚ö†Ô∏è Logic ‚úÖ Resolved ‚ú® Improvement üíæ Memory üîß Style üìù Documentation üìñ Readability üí° Best Practice
          - Include severity level in comment when not obvious from emoji

          Submission:
          - If NO issues found, submit one brief summary comment: "‚úÖ Code review: No issues found. The changes look good!"
          - If issues ARE found, submit ONE review containing inline comments plus a comprehensive summary body.
          - Summary body MUST include:
            * Statistics by category (Critical: X, Security: Y, Performance: Z, etc.)
            * List of files with most issues
            * Priority recommendations (what to fix first)
            * General recommendations for improvement
          - Use GitHub Reviews API to ensure comments are inline:
            - Build JSON array: [{ "path": "<file>", "position": <diff_position>, "body": "..." }]
            - Submit via: gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews -f event=COMMENT -f body="$SUMMARY" -f comments='[$COMMENTS_JSON]'
          - Track comment categories in environment for blocking behavior

          Blocking behavior:
          - Count critical (üö®) and security (üîí) issues found
          - If BLOCKING_REVIEW is true and any üö® or üîí issues were posted: echo "CRITICAL_ISSUES_FOUND=true" >> $GITHUB_ENV
          - Otherwise: echo "CRITICAL_ISSUES_FOUND=false" >> $GITHUB_ENV
          - Always set CRITICAL_ISSUES_FOUND at the end
          '

      - name: Check blocking review results
        if: env.BLOCKING_REVIEW == 'true'
        run: |
          if [ "${CRITICAL_ISSUES_FOUND:-false}" = "true" ]; then
            echo "‚ùå Critical issues found and blocking review is enabled. Failing the workflow."
            exit 1
          else
            echo "‚úÖ No blocking issues found."
          fi

      - name: Summary
        env:
          MODEL_USED: ${{ steps.select-model.outputs.MODEL }}
          MODEL_REASON: ${{ steps.select-model.outputs.MODEL_REASON }}
        run: |
          echo "‚úÖ Code review con Cursor AI completado"
          echo "Modelo utilizado: $MODEL_USED ($MODEL_REASON)"
          echo "Revisa los comentarios en el Pull Request"
