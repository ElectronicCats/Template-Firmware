name: AI Code Review (Cursor CLI)

on:
  pull_request:
    types: [opened, synchronize, reopened, ready_for_review]
  workflow_dispatch:
    inputs:
      model:
        description: 'AI model to use (overrides auto-selection)'
        required: false
        type: string
        default: 'auto'

permissions:
  contents: read
  pull-requests: write
  issues: write

jobs:
  cursor-code-review:
    name: Cursor AI Code Review
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    
    # Concurrency: prevent multiple simultaneous runs of the same PR
    concurrency:
      group: code-review-${{ github.event.pull_request.number }}
      cancel-in-progress: true
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          ref: ${{ github.event.pull_request.head.sha }}
          persist-credentials: false

      - name: Validate required secrets
        run: |
          # Safer method: check if secret exists without exposing its value
          # GitHub Actions treats empty secrets as empty string, so we check for non-empty
          SECRET_CHECK="${{ secrets.CURSOR_API_KEY }}"
          if [ -z "$SECRET_CHECK" ]; then
            echo "::error::CURSOR_API_KEY secret is not configured"
            echo "Please configure it in: Settings > Secrets and variables > Actions"
            exit 1
          fi
          echo "‚úÖ CURSOR_API_KEY is configured"

      - name: Install Cursor CLI
        timeout-minutes: 5
        continue-on-error: false
        run: |
          # Download and verify Cursor CLI installation script
          INSTALL_URL="https://cursor.com/install"
          echo "Downloading Cursor CLI installer..."
          
          # Download with timeout protection and retry logic
          MAX_RETRIES=3
          RETRY_COUNT=0
          DOWNLOAD_SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$DOWNLOAD_SUCCESS" = "false" ]; do
            if [ $RETRY_COUNT -gt 0 ]; then
              echo "Retry attempt $RETRY_COUNT of $MAX_RETRIES..."
              sleep 2
            fi
            
            if curl --max-time 300 --connect-timeout 30 -fsSL "$INSTALL_URL" -o /tmp/cursor-install.sh; then
              DOWNLOAD_SUCCESS=true
            else
              RETRY_COUNT=$((RETRY_COUNT + 1))
            fi
          done
          
          if [ "$DOWNLOAD_SUCCESS" = "false" ]; then
            echo "::error::Failed to download Cursor CLI installer after $MAX_RETRIES attempts"
            exit 1
          fi
          
          # Verify download integrity (check file exists and is not empty)
          if [ ! -s /tmp/cursor-install.sh ]; then
            echo "::error::Failed to download Cursor CLI installer (file is empty)"
            exit 1
          fi
          
          # Basic validation: check if script contains expected content
          if ! grep -q "cursor" /tmp/cursor-install.sh 2>/dev/null; then
            echo "::error::Failed to download valid Cursor CLI installer (invalid content)"
            exit 1
          fi
          
          # Verify script is executable and has valid shebang
          if ! head -1 /tmp/cursor-install.sh | grep -qE "^#!/(bin|usr)/.*sh"; then
            echo "::error::Downloaded file does not appear to be a valid shell script"
            exit 1
          fi
          
          # Calculate and log checksum for verification (optional future enhancement: verify against known hash)
          CHECKSUM=$(sha256sum /tmp/cursor-install.sh | cut -d' ' -f1)
          echo "Downloaded installer checksum: $CHECKSUM"
          
          # Execute installer with error handling
          bash /tmp/cursor-install.sh || {
            echo "::error::Failed to install Cursor CLI"
            exit 1
          }
          
          # Cursor CLI installer completed successfully
          # Newer installer installs to ~/.local/bin, older to ~/.cursor/bin
          # Add both to PATH - the installer message confirms installation success
          export PATH="$HOME/.local/bin:$HOME/.cursor/bin:$PATH"
          echo "$HOME/.local/bin" >> $GITHUB_PATH
          if [ -d "$HOME/.cursor/bin" ]; then
            echo "$HOME/.cursor/bin" >> $GITHUB_PATH
          fi
          
          echo "‚úÖ Cursor CLI installation completed successfully"
          echo "Added ~/.local/bin and ~/.cursor/bin to PATH"
          echo "cursor-agent will be available in subsequent steps"

      - name: Configure git identity
        run: |
          git config user.name "Cursor AI Reviewer"
          git config user.email "cursor-reviewer@noreply.github.com"

      - name: Select optimal AI model based on PR size
        id: select-model
        env:
          MODEL_CONFIG: ${{ github.event.inputs.model || vars.MODEL || 'auto' }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          # If MODEL is manually configured (via workflow_dispatch input or variable) and not 'auto', use it directly
          if [ "$MODEL_CONFIG" != "auto" ]; then
            echo "MODEL=$MODEL_CONFIG" >> $GITHUB_OUTPUT
            echo "MODEL_REASON=Manually configured" >> $GITHUB_OUTPUT
            echo "Using manually configured model: $MODEL_CONFIG"
            exit 0
          fi
          
          # Get PR metrics with error handling
          set +e
          PR_DATA=$(gh pr view ${{ github.event.pull_request.number }} --json additions,deletions,files --jq '{additions, deletions, files: (.files | length)}' 2>&1)
          PR_VIEW_EXIT_CODE=$?
          set -e
          
          if [ $PR_VIEW_EXIT_CODE -ne 0 ]; then
            echo "::error::Failed to fetch PR data"
            # Improved secret masking: match common secret patterns
            echo "$PR_DATA" | sed -E 's/([A-Z_]*API[_-]?KEY|[A-Z_]*TOKEN|password|secret|credential|auth[_-]?token)=[^[:space:]]+/\1=***/gi'
            exit 1
          fi
          
          ADDITIONS=$(echo "$PR_DATA" | jq -r '.additions // 0')
          DELETIONS=$(echo "$PR_DATA" | jq -r '.deletions // 0')
          FILES=$(echo "$PR_DATA" | jq -r '.files // 0')
          TOTAL_LINES=$((ADDITIONS + DELETIONS))
          
          # Validate numeric values
          if ! [[ "$ADDITIONS" =~ ^[0-9]+$ ]] || ! [[ "$DELETIONS" =~ ^[0-9]+$ ]] || ! [[ "$FILES" =~ ^[0-9]+$ ]]; then
            echo "::error::Invalid PR metrics received"
            # Improved secret masking
            echo "$PR_DATA" | sed -E 's/([A-Z_]*API[_-]?KEY|[A-Z_]*TOKEN|password|secret|credential|auth[_-]?token)=[^[:space:]]+/\1=***/gi'
            exit 1
          fi
          
          echo "PR Analysis:"
          echo "  Additions: $ADDITIONS lines"
          echo "  Deletions: $DELETIONS lines"
          echo "  Total changes: $TOTAL_LINES lines"
          echo "  Files changed: $FILES"
          
          # Automatic selection based on PR size and complexity
          # PRIORITY: Claude (Sonnet/Opus) always first > GPT as fallback > Gemini as last resort
          # Available models in Cursor: sonnet-4.5, opus-4.5, gpt-5, gemini-3-pro
          # Small PR: minor changes, few files
          if [ "$TOTAL_LINES" -lt 500 ] && [ "$FILES" -lt 10 ]; then
            SELECTED_MODEL="sonnet-4.5"
            REASON="Small PR: Claude Sonnet (priority), fallback: GPT-5, then Gemini-3-pro"
          
          # Small-medium PR: moderate changes
          elif [ "$TOTAL_LINES" -lt 1500 ] && [ "$FILES" -lt 25 ]; then
            SELECTED_MODEL="sonnet-4.5"
            REASON="Medium PR: Claude Sonnet (priority), fallback: GPT-5, then Gemini-3-pro"
          
          # Medium-large PR: significant changes
          elif [ "$TOTAL_LINES" -lt 3000 ] && [ "$FILES" -lt 40 ]; then
            SELECTED_MODEL="sonnet-4.5"
            REASON="Large PR: Claude Sonnet (priority), fallback: GPT-5, then Gemini-3-pro"
          
          # Large PR: many changes and files
          elif [ "$TOTAL_LINES" -lt 10000 ] && [ "$FILES" -lt 60 ]; then
            SELECTED_MODEL="opus-4.5"
            REASON="Very large PR: Claude Opus (priority), fallback: GPT-5-high, then Gemini-3-pro"
          
          # Massive PR: extreme changes - Opus first, then GPT-5-high, finally Gemini
          else
            SELECTED_MODEL="opus-4.5"
            REASON="Massive PR: Claude Opus (priority), fallback: GPT-5-high, then Gemini-3-pro"
          fi
          
          echo "Selected model: $SELECTED_MODEL ($REASON)"
          echo "MODEL=$SELECTED_MODEL" >> $GITHUB_OUTPUT
          echo "MODEL_REASON=$REASON" >> $GITHUB_OUTPUT

      - name: Validate selected model
        id: validate-model
        env:
          MODEL: ${{ steps.select-model.outputs.MODEL }}
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
        run: |
          echo "Selected model: $MODEL"
          # Note: Full model validation would require calling Cursor API to check availability.
          # The model will be validated when cursor-agent runs - if invalid, it will fail with a clear error.
          # This step logs the selected model for visibility in the workflow run.
          echo "MODEL_VALIDATED=true" >> $GITHUB_OUTPUT

      - name: Perform automated code review with Cursor
        timeout-minutes: 30
        env:
          CURSOR_API_KEY: ${{ secrets.CURSOR_API_KEY }}
          # MODEL: AI model to use
          #   - 'auto' (default): Automatic selection based on PR size
          #     Model priority: Claude (Sonnet/Opus) > GPT > Gemini
          #   Claude models (priority):
          #   - 'sonnet-4.5': Claude Sonnet 4.5 (default for small/medium/large PRs)
          #   - 'sonnet-4.5-thinking': Claude Sonnet with extended reasoning
          #   - 'opus-4.5': Claude Opus 4.5 (best quality, for very large/complex PRs)
          #   - 'opus-4.5-thinking': Claude Opus with extended reasoning
          #   GPT models (fallback if Claude unavailable):
          #   - 'gpt-5': GPT-5 standard
          #   - 'gpt-5.1': GPT-5.1 improved
          #   - 'gpt-5-high': GPT-5 high quality
          #   - 'gpt-5-codex': GPT-5 optimized for code
          #   - 'gpt-5.1-codex': GPT-5.1 optimized for code
          #   - 'opus-4.1': Opus 4.1 (alternative)
          #   Gemini models (final fallback):
          #   - 'gemini-3-pro': Gemini 3 Pro
          #   Other:
          #   - 'composer-1': Composer model
          #   - 'grok': Grok model
          #   - 'auto': Auto-selection by Cursor
          MODEL: ${{ steps.select-model.outputs.MODEL }}
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BLOCKING_REVIEW: ${{ vars.BLOCKING_REVIEW || 'false' }}
          REVIEW_MAX_COMMENTS: ${{ vars.REVIEW_MAX_COMMENTS || '20' }}
          REVIEW_DETAIL_LEVEL: ${{ vars.REVIEW_DETAIL_LEVEL || 'detailed' }}
        run: |
          set -e
          echo "Starting code review with model: $MODEL"
          
          # Execute cursor-agent with error handling and timeout protection
          cursor-agent --force --model "$MODEL" --output-format=text --print 'You are operating in a GitHub Actions runner performing automated code review for embedded systems firmware. The gh CLI is available and authenticated via GH_TOKEN. You may comment on pull requests.

          Context:
          - Repo: ${{ github.repository }}
          - PR Number: ${{ github.event.pull_request.number }}
          - PR Head SHA: ${{ github.event.pull_request.head.sha }}
          - PR Base SHA: ${{ github.event.pull_request.base.sha }}
          - Blocking Review: ${{ env.BLOCKING_REVIEW }}
          - Project Type: Embedded Systems Firmware (C/C++)
          - Review Detail Level: ${{ env.REVIEW_DETAIL_LEVEL }}
          - Max Comments: ${{ env.REVIEW_MAX_COMMENTS }}
          - Selected Model: ${{ env.MODEL }} (auto-selected based on PR size)
          
          Objectives:
          1) Review the current PR diff and flag issues specific to embedded firmware development (all severity levels if detail level is detailed).
          2) Leave concise inline comments (1-2 sentences) on changed lines only.
          3) Provide a comprehensive summary with statistics at the end.
          4) Check if existing review comments have been addressed.
          5) Prioritize fixes by severity and impact.

          Procedure:
          - Get existing comments: gh pr view --json comments
          - Get diff: gh pr diff
          - Get changed files with patches: gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/files --paginate --jq '.[] | {filename,patch}'
          - Compute exact inline anchors for each issue (file path + diff position).
          - Comments MUST be placed inline on the changed line in the diff, not as top-level comments.
          - Focus on files with extensions: .c, .cpp, .h, .hpp, .cc, .cxx

          Focus Areas (Embedded Systems - All Severity Levels):
          
          MEMORY MANAGEMENT:
          - Stack/heap overflow risks (analyze stack sizes, dynamic allocations)
          - Memory leaks (malloc/free, new/delete mismatches)
          - Buffer overflows/underflows
          - Static vs dynamic allocation best practices
          - Memory fragmentation issues
          - Stack usage estimation and warnings
          - Double free or use-after-free vulnerabilities
          - Uninitialized memory access
          
          RTOS COMMON PATTERNS:
          - FreeRTOS: tasks, queues, semaphores, mutexes, timers
          - Zephyr: threads, work queues, kernel objects, device drivers
          - ThreadX: threads, queues, timers, event flags
          - Bare metal: interrupts, state machines, event loops
          - Task priorities and scheduling
          - Task stack size adequacy
          
          CONCURRENCY & THREADING:
          - Race conditions in multi-threading contexts
          - Deadlocks and livelocks
          - Critical sections and protection of shared data
          - Interrupt safety (ISR vs task context, reentrancy)
          - Preemption issues
          - Mutex/semaphore usage patterns
          - Lock ordering to prevent deadlocks
          
          RESOURCE MANAGEMENT:
          - Resource leaks (handles, timers, peripherals)
          - Lifecycle management (init/deinit pairs)
          - Peripheral configuration conflicts
          - GPIO/hardware state management
          - DMA channel management
          - Interrupt handler registration/cleanup
          
          ERROR HANDLING & ROBUSTNESS:
          - Error handling in critical operations
          - Retry logic and timeouts
          - Watchdog management and feeding
          - Failure recovery mechanisms
          - Null pointer checks before dereferencing
          - Assertions vs error returns (appropriate usage)
          - Edge case handling
          - Input validation
          
          PERFORMANCE:
          - Blocking calls in ISRs (critical anti-pattern)
          - Excessive polling (use interrupts instead)
          - Inefficient algorithms for resource-constrained environments
          - Power consumption patterns and optimization opportunities
          - CPU usage optimization
          - Loop optimization (unnecessary iterations)
          - Function call overhead in hot paths
          
          SECURITY:
          - Buffer overflows
          - Integer overflows and underflows
          - Unsafe string functions (strcpy, sprintf, etc.)
          - Cryptographic implementation flaws (if applicable)
          - Secure boot / OTA security (if applicable)
          - Secret/hardcoded credentials
          - Side-channel vulnerabilities
          
          EMBEDDED CODE PATTERNS:
          - Volatile usage (registers, shared memory)
          - Register access patterns (read-modify-write correctness)
          - Bit manipulation correctness
          - Interrupt priorities configuration
          - DMA configuration and synchronization
          - Hardware abstraction layers (proper abstraction)
          - Endianness considerations
          - Atomic operations (when needed)
          
          CODE QUALITY & STYLE:
          - Compliance with clang-format style (check if code follows project .clang-format)
          - Naming conventions consistency
          - Function complexity (avoid overly long functions)
          - Cyclomatic complexity warnings
          - Magic numbers (use constants/config instead)
          - Documentation (comments in critical functions)
          - Code organization and structure
          - Duplicate code detection
          
          READABILITY & BEST PRACTICES:
          - Variable naming clarity
          - Function and module organization
          - Code comments quality and necessity
          - Consistent coding style
          - Type safety improvements
          - Const correctness
          - Macro usage appropriateness

          Commenting rules:
          - Max ${{ env.REVIEW_MAX_COMMENTS }} inline comments total; prioritize critical issues first, then include all severity levels
          - One issue per comment; place on the exact changed line
          - All issue comments MUST be inline (anchored to file and line/position in PR diff)
          - Natural, specific, and actionable tone
          - Use emojis to categorize: üö® Critical üîí Security ‚ö° Performance ‚ö†Ô∏è Logic ‚úÖ Resolved ‚ú® Improvement üíæ Memory üîß Style üìù Documentation üìñ Readability üí° Best Practice
          - Include severity level in comment when not obvious from emoji

          Submission:
          - If NO issues found, submit one brief summary comment: "‚úÖ Code review: No issues found. The changes look good!"
          - If issues ARE found, submit ONE review containing inline comments plus a comprehensive summary body.
          - Summary body MUST include:
            * Statistics by category (Critical: X, Security: Y, Performance: Z, etc.)
            * List of files with most issues
            * Priority recommendations (what to fix first)
            * General recommendations for improvement
          - Use GitHub Reviews API to ensure comments are inline:
            - Build JSON array: [{ "path": "<file>", "position": <diff_position>, "body": "..." }]
            - Submit via: gh api repos/${{ github.repository }}/pulls/${{ github.event.pull_request.number }}/reviews -f event=COMMENT -f body="$SUMMARY" -f comments='[$COMMENTS_JSON]'
          - Track comment categories in environment for blocking behavior

          Blocking behavior:
          - Count critical (üö®) and security (üîí) issues found
          - If BLOCKING_REVIEW is true and any üö® or üîí issues were posted: 
            * Set CRITICAL_ISSUES_FOUND=true using $GITHUB_ENV for GitHub Actions variable propagation
            * Command: echo "CRITICAL_ISSUES_FOUND=true" >> $GITHUB_ENV
          - Otherwise: 
            * Set CRITICAL_ISSUES_FOUND=false using $GITHUB_ENV
            * Command: echo "CRITICAL_ISSUES_FOUND=false" >> $GITHUB_ENV
          - Always set CRITICAL_ISSUES_FOUND at the end of review
          - Use $GITHUB_ENV file to ensure variable is available to subsequent workflow steps
          ' || {
            EXIT_CODE=$?
            echo "::error::cursor-agent failed with exit code $EXIT_CODE"
            echo "Model used: $MODEL"
            echo "Check CURSOR_API_KEY configuration and model availability"
            exit $EXIT_CODE
          }
          
          echo "‚úÖ Code review completed successfully"

      - name: Check blocking review results
        if: env.BLOCKING_REVIEW == 'true'
        run: |
          if [ "${CRITICAL_ISSUES_FOUND:-false}" = "true" ]; then
            echo "::error::Critical issues found and blocking review is enabled. Failing the workflow."
            exit 1
          else
            echo "‚úÖ No blocking issues found."
          fi

      - name: Summary
        env:
          MODEL_USED: ${{ steps.select-model.outputs.MODEL }}
          MODEL_REASON: ${{ steps.select-model.outputs.MODEL_REASON }}
        run: |
          echo "‚úÖ Code review with Cursor AI completed"
          echo "Model used: $MODEL_USED ($MODEL_REASON)"
          echo "Please review the comments in the Pull Request"
